<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chxin&#39;s Blog</title>
  
  <subtitle>Hello,World.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-05T16:22:26.003Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>陈鑫</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试相关问题</title>
    <link href="http://yoursite.com/2019/06/05/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/06/05/面试相关问题/</id>
    <published>2019-06-05T13:57:23.000Z</published>
    <updated>2019-06-05T16:22:26.003Z</updated>
    
    <content type="html"><![CDATA[<h3 id="怎么防止卖超或者怎么设置一个秒杀系统"><a href="#怎么防止卖超或者怎么设置一个秒杀系统" class="headerlink" title="怎么防止卖超或者怎么设置一个秒杀系统"></a>怎么防止卖超或者怎么设置一个秒杀系统</h3><p> 答：</p><ul><li><p>redis限流 + Redis缓存 + 乐观锁更新 + 消息中间件异步</p></li><li><p>redis限流：可以使用redis限流，大量的请求进来但是能更新数据库的只有库存数量的请求，为了减少服务器的压力，所以进行限流，比如限制100个请求过来，去争夺这10个商品</p></li><li><p>Redis缓存：库存先缓存到redis里面，每次查库存和版本号从redis里面查，扣库存时更新redis</p></li><li><p>乐观锁更新库存：库存表里加上版本号的字段，带上版本号一起进行更新</p></li><li><p>中间件异步：将更新库存和创建订单的操作异步，库存更新成功之后就将订单信息发给中间件，这样一个请求就可以直接返回了。消费程序再对数据进行入库落地。因为异步了，所以最终需要采取回调或者是其他提醒的方式提醒用户购买完成。</p></li></ul><h3 id="Mybatis是怎么通过dao里面的接口找到对应的sql的"><a href="#Mybatis是怎么通过dao里面的接口找到对应的sql的" class="headerlink" title="Mybatis是怎么通过dao里面的接口找到对应的sql的"></a>Mybatis是怎么通过dao里面的接口找到对应的sql的</h3><p> 答：</p><ul><li><p>比较复杂，简单点说就是根据namespace和id找到的，哈哈</p><pre><code>1、Mapper接口在初始SqlSessionFactory注册的。2、Mapper接口注册在了名为 MapperRegistry 类的 HashMap中，   key = Mapper class； value = 创建当前Mapper的工厂。3、Mapper 注册之后，可以从SqlSession中get4、SqlSession.getMapper 运用了 JDK动态代理，产生了目标Mapper接口的代理对象。5、动态代理的代理类是 MapperProxy ，这里边最终完成了增删改查方法的调用。</code></pre></li></ul><h3 id="JDK的动态代理和CGLIB有什么区别"><a href="#JDK的动态代理和CGLIB有什么区别" class="headerlink" title="JDK的动态代理和CGLIB有什么区别"></a>JDK的动态代理和CGLIB有什么区别</h3><p> 答：</p><ul><li><p>JDK动态代理依赖Proxy类和InvocationHandler接口，调用Proxy类中的newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)方法可以创建一个动态代理对象，但是这个方法需要3个参数，前两个参数是固定的，但第三个参数比较麻烦，需要我们创建一个类MyInvocationHandler来实现InvocationHandler接口，这个类里面要重写invoke()方法。</p></li><li><p>JDK动态代理只能对实现了接口的类生成代理对象；cglib可以对任意类生成代理对象，它的原理是对目标对象进行继承代理，实际代理的是代理对象的子类，如果目标对象被final修饰，那么该类无法被cglib代理。</p></li><li><p>Spring框架的一大特点就是AOP，SpringAOP的本质就是动态代理，如果被代理对象实现了接口，就优先使用JDK代理，如果没有实现接口，就用用cglib代理。</p></li></ul><h3 id="拦截器相关"><a href="#拦截器相关" class="headerlink" title="拦截器相关"></a>拦截器相关</h3><p> 答：</p><ul><li><p>拦截器（Interceptor）：它依赖于web框架，在SpringMVC中就是依赖于SpringMVC框架。在实现上,基于Java的反射机制，属于面向切面编程（AOP）的一种运用，就是在service或者一个方法前，调用一个方法，或者在方法后，调用一个方法，比如动态代理就是拦截器的简单实现，在调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在调用方法后打印出字符串，甚至在抛出异常的时候做业务逻辑的操作。由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。但是缺点是只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理。</p></li><li><p>过滤器(Filter)：它依赖于servlet容器。在实现上，基于函数回调，只初始化一次。使用过滤器的目的，是用来做一些过滤操作，获取我们想要获取的数据，比如：在Javaweb中，对传入的request、response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者Controller进行业务逻辑操作。通常用的场景是：在过滤器中修改字符编码（CharacterEncodingFilter）、在过滤器中修改HttpServletRequest的一些参数（XSSFilter(自定义过滤器)），如：过滤低俗文字、危险字符等。</p></li><li><p>区别：</p><pre><code>1、Filter需要在web.xml中配置，依赖于Servlet2、Interceptor需要在SpringMVC中配置，依赖于框架3、Filter的执行顺序在Interceptor之前4、两者的本质区别：拦截器（Interceptor）是基于Java的反射机制，而过滤器（Filter）   是基于函数回调。从灵活性上说拦截器（Interceptor）功能更强大些，过滤器（Filter）   能做的事情，拦截器（Interceptor）都能做，而且可以在请求前，请求后执行，比较灵活。   过滤器（Filter）主要是针对URL地址做一个编码的事情、过滤掉没用的参数、安全校验（比   较泛的，比如登录不登录之类），太细的话，还是建议用interceptor。不过还是根据不同情   况选择合适的</code></pre></li></ul><h3 id="哨兵的选举策略"><a href="#哨兵的选举策略" class="headerlink" title="哨兵的选举策略"></a>哨兵的选举策略</h3><p> 答：不知道，顺便问一句，这个东西知道了有什么用吗？能让我开上法拉利吗？</p><h3 id="synchronized做了那些优化"><a href="#synchronized做了那些优化" class="headerlink" title="synchronized做了那些优化"></a>synchronized做了那些优化</h3><p> 这个问题以后碰到了再来看。</p><h3 id="volatile是怎么实现可见性的"><a href="#volatile是怎么实现可见性的" class="headerlink" title="volatile是怎么实现可见性的"></a>volatile是怎么实现可见性的</h3><p> 答：</p><ul><li><p>当某个线程需要修改一个数据时，事实上步骤是如下的：</p><pre><code>1、将主存中的数据加载到缓存中2、CPU对缓存中的数据进行修改3、将修改后的值刷新到内存中</code></pre><p> 但是不同的CPU之间是无法感知其他CPU对这个变量的修改的，最终就可能导致结果与我们的预期不符。</p></li><li><p>而使用了volatile关键字之后，情况就有所不同，volatile关键字有两层语义：</p><pre><code>1、立即将缓存中数据写会到内存中2、其他处理器通过嗅探总线上传播过来了数据监测自己缓存的值是不是过期了，如果过期了，就  会对应的缓存中的数据置为无效。而当处理器对这个数据进行修改时，会重新从内存中把数据读  取到缓存中进行处理。</code></pre><p> 在这种情况下，不同的CPU之间就可以感知其他CPU对变量的修改，并重新从内存中加载更新后的值，因此可以解决可见性问题。</p></li></ul><h3 id="ArrayList怎么扩容的"><a href="#ArrayList怎么扩容的" class="headerlink" title="ArrayList怎么扩容的"></a>ArrayList怎么扩容的</h3><p> 答: 添加一个元素，首先计算当前的array所需的最小容量的大小，判断是否需要扩容。</p><p> 当需要扩容时：</p><ul><li><p>得到当前的ArrayList的容量(oldCapacity)。</p></li><li><p>计算出扩容后的新容量(newCapacity)，其值(oldCapacity + (oldCapacity &gt;&gt;1))约是    oldCapacity 的1.5倍。</p></li><li><p>这里采用的是移位运算。为什么采用这种方法呢？应该是出于效率的考虑。</p></li><li><p>当newCapacity小于所需最小容量，那么将所需最小容量赋值给newCapacity。</p></li><li><p>newCapacity大于ArrayList的所允许的最大容量,处理。进行数据的复制，完成向ArrayList实例添加元素操作。</p></li><li><p>每次array的size到达当前的容量最大值后，再插入数据就会造成扩容。</p></li></ul><h3 id="映射器处理器是怎么通过URL找到对应的处理器的"><a href="#映射器处理器是怎么通过URL找到对应的处理器的" class="headerlink" title="映射器处理器是怎么通过URL找到对应的处理器的"></a>映射器处理器是怎么通过URL找到对应的处理器的</h3><p> 以后碰到了在来看。</p><h3 id="当你在浏览器地址栏输入一个URL后回车，浏览器做了什么？"><a href="#当你在浏览器地址栏输入一个URL后回车，浏览器做了什么？" class="headerlink" title="当你在浏览器地址栏输入一个URL后回车，浏览器做了什么？"></a>当你在浏览器地址栏输入一个URL后回车，浏览器做了什么？</h3><p> 答：</p><ul><li><p>URL输入</p></li><li><p>DNS解析，将输入的网址解析成IP地址</p></li><li><p>TCP连接，经过三次握手建立TCP连接</p><pre><code>1、第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等   待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。2、第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN   包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；3、第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发   送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</code></pre></li><li><p>发送HTTP请求</p><pre><code>客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分：1、请求方法URI协议/版本。比如：   GET/sample.jsp HTTP/1.12、请求头(Request Header)请求头包含许多有关的客户端环境和请求正文的有用信息。   例如，请求头可以声明浏览器所用的语言，请求正文的长度等。比如：    Accept:image/gif.image/jpeg.*/*    Accept-Language:zh-cn    Connection:Keep-Alive    Host:localhost    User-Agent:Mozila/4.0(compatible:MSIE5.01:Windows NT5.0)    Accept-Encoding:gzip,deflate.注意：请求头和请求正文之间有一个空行，这个空行非常重要，它表示请求头已经结束，接下来的是请求正文。3、请求正文：请求正文中可以包含客户提交的查询字符串信息。比如：    username=jinqiao&amp;password=1234123合起来就是一个完整的HTTP请求例子</code></pre></li><li><p>服务器处理请求</p></li><li><p>服务器响应请求</p></li><li><p>浏览器解析渲染页面</p></li><li><p>连接结束</p></li></ul><h3 id="Map上的链表什么时候变成红黑树"><a href="#Map上的链表什么时候变成红黑树" class="headerlink" title="Map上的链表什么时候变成红黑树"></a>Map上的链表什么时候变成红黑树</h3><p> 答：链表长度为8的时候，初始化是链表保存的，其查找性能是O(n)，而树结构能将查找性能提升到O(log(n))。当链表长度很小的时候，即使遍历，速度也非常快，但是当链表长度不断变长，肯定会对查询性能有一定的影响，所以才需要转成树</p><ul><li><p>这个时候就有一些面试管问：可是为什么是8呢？</p></li><li><p>选择8是空间和时间的权衡，不是拍拍屁股决定的，是做java的那些人是根据概率统计决定的</p></li></ul><h3 id="什么是自旋锁"><a href="#什么是自旋锁" class="headerlink" title="什么是自旋锁"></a>什么是自旋锁</h3><p> 答：首先是一种锁，与互斥锁相似，基本作用是用于线程（进程）之间的同步。与普通锁不同的是，一个线程A在获得普通锁后，如果再有线程B试图获取锁，那么这个线程B将会挂起（阻塞）；试想下，如果两个线程资源竞争不是特别激烈，而处理器阻塞一个线程引起的线程上下文的切换的代价高于等待资源的代价的时候（锁的已保持者保持锁时间比较短），那么线程B可以不放弃CPU时间片，而是在“原地”忙等，直到锁的持有者释放了该锁，这就是自旋锁的原理，可见自旋锁是一种非阻塞锁。</p><h3 id="对Lock相关锁的理解"><a href="#对Lock相关锁的理解" class="headerlink" title="对Lock相关锁的理解"></a>对Lock相关锁的理解</h3><h3 id="什么是hash算法"><a href="#什么是hash算法" class="headerlink" title="什么是hash算法"></a>什么是hash算法</h3><p> 答：百科是这样定义哈希算法的：哈希算法可以将任意长度的二进制值映射为较短的，固定长度的二进制值。我们把这个二进制值成为哈希值。</p><h3 id="hash冲突怎么回事"><a href="#hash冲突怎么回事" class="headerlink" title="hash冲突怎么回事"></a>hash冲突怎么回事</h3><p> 答：由于哈希算法被计算的数据是无限的，而计算后的结果范围有限，因此总会存在不同的数据经过计算后得到的值相同，这就是哈希冲突</p><h3 id="怎么解决hash冲突"><a href="#怎么解决hash冲突" class="headerlink" title="怎么解决hash冲突"></a>怎么解决hash冲突</h3><p> 答：解决哈希冲突的方法一般有：开放定址法、链地址法（拉链法）、再哈希法、建立公共溢出区等方法。具体解释Google或百度。</p><h3 id="为什么循环删除ArrayList会出错"><a href="#为什么循环删除ArrayList会出错" class="headerlink" title="为什么循环删除ArrayList会出错"></a>为什么循环删除ArrayList会出错</h3><p> 答：</p><ul><li><p>for循环删除数组里面的元素会向左移，list的长度也会发生变化，但是for循环中的i的数值是自增的，比如说上一次遍历到了第2个元素，下标为1，然后删除，下一次遍历i变成了3，但是第三个元素的下标还是1，这个时候第三个元素就会遍历不到，所以可能会导致少遍历了某个或几个元素。可以用list的长度自减的方式进行删除。</p></li><li><p>foreach循环删除元素的时候，foreach写法是对实际的Iterable、hasNext、next方法的简写，迭代器内部会做修改次数检查，所以会并发异常。要避免这种情况的出现则在使用迭代器迭代时（显示或for-each的隐式）不要使用ArrayList的remove，改为用Iterator的remove即可。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;怎么防止卖超或者怎么设置一个秒杀系统&quot;&gt;&lt;a href=&quot;#怎么防止卖超或者怎么设置一个秒杀系统&quot; class=&quot;headerlink&quot; title=&quot;怎么防止卖超或者怎么设置一个秒杀系统&quot;&gt;&lt;/a&gt;怎么防止卖超或者怎么设置一个秒杀系统&lt;/h3&gt;&lt;p&gt; 答：&lt;/p
      
    
    </summary>
    
      <category term="面试相关" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring的核心机制</title>
    <link href="http://yoursite.com/2019/06/04/Spring%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/06/04/Spring的核心机制/</id>
    <published>2019-06-04T15:00:28.000Z</published>
    <updated>2019-06-07T09:37:41.425Z</updated>
    
    <content type="html"><![CDATA[<p>首先，Spring是一个轻量级的（面向切面AOP、IOC控制反转）容器框架。</p><h2 id="Spring的优点"><a href="#Spring的优点" class="headerlink" title="Spring的优点"></a>Spring的优点</h2><ol><li>降低组件之间的耦合性</li><li>使程序员更加专注于自己的核心业务，像日志、安全等抽出来统一处理</li><li>方便单元测试</li><li>方便事务处理</li><li>不强制应用完全依赖Spring，开发者可以自由选用Sprig的部分或全部功能</li><li>对主流框架提供了集成支持，如Hibernate，JPA，Struts等</li><li>属于低侵入式设计，代码污染度极低</li><li>提供了单例模式的支持</li></ol><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>把业务逻辑和系统级别的服务分离开来，使程序员更加专注于自己的业务逻辑，而不需要管系统级别的服务。容器中的对象能享有容器中的公共服务（事务、安全等）。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>AOP是基于动态代理的。用到了代理模式，代理模式是一种静态代理，而动态代理就是利用反射和动态编译将代理模式变成动态的。得知被代理类后通过反射得知他的一切信息，然后动态编译成代理类的class文件（动态组装成代理类，生成java文件，再编译成class文件）。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>提供另外一种变成思路，可以把类似的行为抽出来统一处理。</p><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>依赖注入（DI）和控制反转（nversion of Control）是同一个概念。控制权的反转，在程序中对象的控制权转到容器而不是程序员自己控制，促进了松耦合。依赖注入，将相互依赖的对象分离，在Spring配置文件中，描述他们的依赖关系，用到一个对象时注入，而不需要New一个对象。</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>通过工厂+反射将我们的bean放到容器中，当我们想用某个bean的时候，只需要调用getBean(“beanID”)方法。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>解耦、统一管理bean，缺点占用内存多、构造对象慢</p><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><ol><li><p>建立  </p><pre><code>Bean的建立由BeanFactory读取Bean定义文件，并生成各个实例。  </code></pre></li><li><p>初始化</p><pre><code>依赖注入  setBeanName()  setBeanFactory()  processBeforeInitialization()  初始化之前都会执行这个实例的processBeforeInitialization()方法。  afterPropertiesSet()   init-method  processAfterInitialization()  </code></pre></li><li><p>使用Bean进行业务逻辑   </p></li><li><p>销毁  </p><pre><code>destroy()  destroy-method</code></pre></li></ol><h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><ol><li><p>Singleton: 这是默认的作用域，这种范围确保不管接受多少个请求，每个容器中只有一个bean的实例，单例模式有BeanFactory自身维护；</p></li><li><p>rototype: 原形范围与单例范围相反，为每一个bean请求提供一个实例；</p></li><li><p>Request: 在请求bean范围内会为每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收；</p></li><li><p>Session: 与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效；</p></li></ol><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><ol><li><p>初始化阶段，调用init()方法</p></li><li><p>响应客户请求阶段，调用service()方法</p></li><li><p>终止阶段，调用destroy()方法</p></li></ol><h2 id="设值注入和构造注入及其区别"><a href="#设值注入和构造注入及其区别" class="headerlink" title="设值注入和构造注入及其区别"></a>设值注入和构造注入及其区别</h2><ol><li><p>设值注入：类中定义setter（）方法，在配置文件中注入参数</p><pre><code>property name=&quot;country&quot; value=&quot;China&quot; /&gt;</code></pre></li><li><p>构造注入：类中声明一个构造方法，并在此方法的参数中定义要注入的对象。</p></li></ol><h3 id="设值注入优点"><a href="#设值注入优点" class="headerlink" title="设值注入优点"></a>设值注入优点</h3><ol><li><p>与传统的JavaBean的写法更相似，程序开发人员更容易理解、接受，依赖关系显得更加直观、自然。</p></li><li><p>对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。而设值注入不会</p></li><li><p>在某些属性可选的情况下，多参数的构造器更加笨重。</p></li></ol><h3 id="构造注入优点"><a href="#构造注入优点" class="headerlink" title="构造注入优点"></a>构造注入优点</h3><ol><li><p>构造注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入。</p></li><li><p>对于依赖关系无须变化的Bean，构造注入更有用处。</p></li></ol><p>建议：采用设值注入为主，构造注入为辅的注入策略。对于依赖关系无需变化的注入，尽量采用构造注入；而其它的依赖关系的注入，则考虑设值注入。</p><h2 id="Spring实例化bean的三种方法"><a href="#Spring实例化bean的三种方法" class="headerlink" title="Spring实例化bean的三种方法"></a>Spring实例化bean的三种方法</h2><ol><li><p>通过构造函数</p></li><li><p>通过静态工厂方法</p><pre><code>factory-method=&quot;静态方法&quot;/&gt;</code></pre></li><li><p>通过实例工厂方法</p><pre><code>factory-method=&quot;createClientServiceInstance&quot;/&gt;</code></pre></li></ol><p>Bean的参数有id、class、factory-bean、factory-method等</p><h2 id="Spring事物管理简单介绍"><a href="#Spring事物管理简单介绍" class="headerlink" title="Spring事物管理简单介绍"></a>Spring事物管理简单介绍</h2><p>包括声明式事务和编程式事务，编程式的，比较灵活，但是代码量大，存在重复的代码比较多；声明式的比编程式的更灵活，最大的好处是大大减少了代码量。编程式不常用，接下来介绍声明式事务管理。</p><p>声明式事务管理建立在AOP之上的，动态代理实现其机制（不改变源码，对原有的功能动态扩展）。声明式事务管理使业务代码不受污染，这正是spring倡导的非侵入式的开发方式。声明式事物处理也有五种不同的配置方式，单常用的是基于 @Transactional注解的声明式事务管理。此时在DAO上需加上@Transactional注解，在需要事务处理的类或方法上都可以加。</p><p>Spring配置文件中关于事务配置总是由三个组成部分，分别是DataSource、TransactionManager和代理机制这三部分，无论哪种配置方式，一般变化的只是代理机制这部分。</p><p>TransactionDefinition接口定义了四种事物属性是我们需要知道的</p><h3 id="事物传播行为"><a href="#事物传播行为" class="headerlink" title="事物传播行为"></a>事物传播行为</h3><p>在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。</p><ol><li><p>TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。</p></li><li><p>TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</p></li><li><p>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</p></li><li><p>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p></li><li><p>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</p></li><li><p>TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</p></li><li><p>TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</p></li></ol><h3 id="事物隔离级别"><a href="#事物隔离级别" class="headerlink" title="事物隔离级别"></a>事物隔离级别</h3><ol><li><p>TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。</p></li><li><p>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。</p></li><li><p>TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。</p></li><li><p>TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。</p></li><li><p>TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</p></li></ol><h3 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h3><p>所谓事务超时，就是指一个事务所准许实行的最长时辰，假定跨越该时辰限制但事务还没有完成，则自动回滚事务。</p><h3 id="事务只读属性"><a href="#事务只读属性" class="headerlink" title="事务只读属性"></a>事务只读属性</h3><p>只读事务用于客户代码只读但不修改数据的情形，只读事务用于特定情景下的优化，比如使用Hibernate的时候</p><h2 id="SpringMVC流程"><a href="#SpringMVC流程" class="headerlink" title="SpringMVC流程"></a>SpringMVC流程</h2><ol><li><p>用户发送请求至前端控制器DispatcherServlet</p></li><li><p>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p></li><li><p>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p></li><li><p>DispatcherServlet选择合适的HandlerAdapter处理器适配器调用处理器</p></li><li><p>执行处理器(Controller，也叫后端控制器)。</p></li><li><p>Controller执行完成返回ModelAndView</p></li><li><p>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</p></li><li><p>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</p></li><li><p>ViewReslover解析后返回具体View</p></li><li><p>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</p></li><li><p>DispatcherServlet响应用户</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，Spring是一个轻量级的（面向切面AOP、IOC控制反转）容器框架。&lt;/p&gt;
&lt;h2 id=&quot;Spring的优点&quot;&gt;&lt;a href=&quot;#Spring的优点&quot; class=&quot;headerlink&quot; title=&quot;Spring的优点&quot;&gt;&lt;/a&gt;Spring的优点&lt;/h2
      
    
    </summary>
    
      <category term="spring" scheme="http://yoursite.com/categories/spring/"/>
    
    
  </entry>
  
</feed>
