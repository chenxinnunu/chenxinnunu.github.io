<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试相关问题]]></title>
    <url>%2F2019%2F06%2F05%2F%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[怎么防止卖超 答： redis限流 + Redis缓存 + 乐观锁更新 + 消息中间件异步 redis限流：可以使用redis限流，大量的请求进来但是能更新数据库的只有库存数量的请求，为了减少服务器的压力，所以进行限流，比如限制100个请求过来，去争夺这10个商品 Redis缓存：库存先缓存到redis里面，每次查库存和版本号从redis里面查，扣库存时更新redis， 乐观锁更新库存：库存表里加上版本号的字段，带上版本号一起进行更新 中间件异步：将更新库存和创建订单的操作异步，库存更新成功之后就将订单信息发给中间件，这样一个请求就可以直接返回了。消费程序再对数据进行入库落地。因为异步了，所以最终需要采取回调或者是其他提醒的方式提醒用户购买完成。 mybatis是怎么通过dao里面的接口找到对应的sql的 答： 比较复杂，简单点说就是根据namespace和id找到的，哈哈 Mapper接口在初始SqlSessionFactory注册的。 Mapper接口注册在了名为 MapperRegistry 类的 HashMap中， key = Mapper class； value = 创建当前Mapper的工厂。 Mapper 注册之后，可以从SqlSession中get SqlSession.getMapper 运用了 JDK动态代理，产生了目标Mapper接口的代理对象。 动态代理的代理类是 MapperProxy ，这里边最终完成了增删改查方法的调用。 jdk的动态代理和cglib有什么区别 答： JDK动态代理依赖Proxy类和InvocationHandler接口，调用Proxy类中的newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)方法可以创建一个动态代理对象，但是这个方法需要3个参数，前两个参数是固定的，但第三个参数比较麻烦，需要我们创建一个类MyInvocationHandler来实现InvocationHandler接口，这个类里面要重写invoke()方法。 JDK动态代理只能对实现了接口的类生成代理对象；cglib可以对任意类生成代理对象，它的原理是对目标对象进行继承代理，实际代理的是代理对象的子类，如果目标对象被final修饰，那么该类无法被cglib代理。 Spring框架的一大特点就是AOP，SpringAOP的本质就是动态代理，如果被代理对象实现了接口，就优先使用JDK代理，如果没有实现接口，就用用cglib代理。 拦截器相关 答： 哨兵的选举策略 sycnized做了那些优化 volatile是怎么实现可见性的 ArrayList怎么扩容的 答: 添加一个元素，首先计算当前的array所需的最小容量的大小，判断是否需要扩容。 当需要扩容时： 得到当前的ArrayList的容量(oldCapacity)。 计算出扩容后的新容量(newCapacity)，其值(oldCapacity + (oldCapacity &gt;&gt;1))约是 oldCapacity 的1.5倍。 这里采用的是移位运算。为什么采用这种方法呢？应该是出于效率的考虑。 当newCapacity小于所需最小容量，那么将所需最小容量赋值给newCapacity。 newCapacity大于ArrayList的所允许的最大容量,处理。进行数据的复制，完成向ArrayList实例添加元素操作。 每次array的size到达当前的容量最大值后，再插入数据就会造成扩容。 处理器映射器是怎么通过URL找到对应的处理器的 在浏览器地址栏输入一个 url， 中间会发生什么？ 还有map上的链表什么时候变成红黑树 什么是自旋锁 对Lock相关锁的理解 hash算法怎么实现 hash冲突怎么回事 怎么解决hash冲突 为什么循环删除ArrayList会出错 答： for循环删除数组里面的元素会向左移，list的长度也会发生变化，但是for循环中的i的数值是自增的，比如说上一次遍历到了第2个元素，下标为1，然后删除，下一次遍历i变成了3，但是第三个元素的下标还是1，这个时候第三个元素就会遍历不到，所以可能会导致少遍历了某个或几个元素。可以用list的长度自减的方式进行删除。 foreach循环删除元素的时候，foreach写法是对实际的Iterable、hasNext、next方法的简写，迭代器内部会做修改次数检查，所以会并发异常。要避免这种情况的出现则在使用迭代器迭代时（显示或for-each的隐式）不要使用ArrayList的remove，改为用Iterator的remove即可。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring的核心机制]]></title>
    <url>%2F2019%2F06%2F04%2FSpring%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[首先，Spring是一个轻量级的（面向切面AOP、IOC控制反转）容器框架。 Spring的优点： 降低组件之间的耦合性 使程序员更加专注于自己的核心业务，像日志、安全等抽出来统一处理 方便单元测试 方便事务处理 不强制应用完全依赖Spring，开发者可以自由选用Sprig的部分或全部功能 对主流框架提供了集成支持，如Hibernate，JPA，Struts等 属于低侵入式设计，代码污染度极低 提供了单例模式的支持 AOP和IOCAOP把业务逻辑和系统级别的服务分离开来，使程序员更加专注于自己的业务逻辑，而不需要管系统级别的服务。容器中的对象能享有容器中的公共服务（事务、安全等）。 原理AOP是基于动态代理的。用到了代理模式，代理模式是一种静态代理，而动态代理就是利用反射和动态编译将代理模式变成动态的。得知被代理类后通过反射得知他的一切信息，然后动态编译成代理类的class文件（动态组装成代理类，生成java文件，再编译成class文件）。 优点提供另外一种变成思路，可以把类似的行为抽出来统一处理。 IOC]]></content>
  </entry>
</search>
