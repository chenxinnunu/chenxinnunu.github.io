<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试相关问题]]></title>
    <url>%2F2019%2F06%2F05%2F%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[怎么防止卖超 答： redis限流 + Redis缓存 + 乐观锁更新 + 消息中间件异步 redis限流：可以使用redis限流，大量的请求进来但是能更新数据库的只有库存数量的请求，为了减少服务器的压力，所以进行限流，比如限制100个请求过来，去争夺这10个商品 Redis缓存：库存先缓存到redis里面，每次查库存和版本号从redis里面查，扣库存时更新redis 乐观锁更新库存：库存表里加上版本号的字段，带上版本号一起进行更新 中间件异步：将更新库存和创建订单的操作异步，库存更新成功之后就将订单信息发给中间件，这样一个请求就可以直接返回了。消费程序再对数据进行入库落地。因为异步了，所以最终需要采取回调或者是其他提醒的方式提醒用户购买完成。 mybatis是怎么通过dao里面的接口找到对应的sql的 答： 比较复杂，简单点说就是根据namespace和id找到的，哈哈 1、 Mapper接口在初始SqlSessionFactory注册的。 2、 Mapper接口注册在了名为 MapperRegistry 类的 HashMap中， key = Mapper class； value = 创建当前Mapper的工厂。 3、 Mapper 注册之后，可以从SqlSession中get 4、 SqlSession.getMapper 运用了 JDK动态代理，产生了目标Mapper接口的代理对象。 5、 动态代理的代理类是 MapperProxy ，这里边最终完成了增删改查方法的调用。 jdk的动态代理和cglib有什么区别 答： JDK动态代理依赖Proxy类和InvocationHandler接口，调用Proxy类中的newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)方法可以创建一个动态代理对象，但是这个方法需要3个参数，前两个参数是固定的，但第三个参数比较麻烦，需要我们创建一个类MyInvocationHandler来实现InvocationHandler接口，这个类里面要重写invoke()方法。 JDK动态代理只能对实现了接口的类生成代理对象；cglib可以对任意类生成代理对象，它的原理是对目标对象进行继承代理，实际代理的是代理对象的子类，如果目标对象被final修饰，那么该类无法被cglib代理。 Spring框架的一大特点就是AOP，SpringAOP的本质就是动态代理，如果被代理对象实现了接口，就优先使用JDK代理，如果没有实现接口，就用用cglib代理。 拦截器相关 答： 拦截器（Interceptor）：它依赖于web框架，在SpringMVC中就是依赖于SpringMVC框架。在实现上,基于Java的反射机制，属于面向切面编程（AOP）的一种运用，就是在service或者一个方法前，调用一个方法，或者在方法后，调用一个方法，比如动态代理就是拦截器的简单实现，在调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在调用方法后打印出字符串，甚至在抛出异常的时候做业务逻辑的操作。由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。但是缺点是只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理。 过滤器(Filter)：它依赖于servlet容器。在实现上，基于函数回调，只初始化一次。使用过滤器的目的，是用来做一些过滤操作，获取我们想要获取的数据，比如：在Javaweb中，对传入的request、response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者Controller进行业务逻辑操作。通常用的场景是：在过滤器中修改字符编码（CharacterEncodingFilter）、在过滤器中修改HttpServletRequest的一些参数（XSSFilter(自定义过滤器)），如：过滤低俗文字、危险字符等。 区别： 1、Filter需要在web.xml中配置，依赖于Servlet 2、 Interceptor需要在SpringMVC中配置，依赖于框架 3、 Filter的执行顺序在Interceptor之前 4、 两者的本质区别：拦截器（Interceptor）是基于Java的反射机制，而过滤器（Filter）是基于函数回调。从灵活性上说拦截器（Interceptor）功能更强大些，过滤器（Filter）能做的事情，拦截器（Interceptor）都能做，而且可以在请求前，请求后执行，比较灵活。过滤器（Filter）主要是针对URL地址做一个编码的事情、过滤掉没用的参数、安全校验（比较泛的，比如登录不登录之类），太细的话，还是建议用interceptor。不过还是根据不同情况选择合适的 哨兵的选举策略 答：不知道，顺便问一句，这个东西知道了有什么用吗？能让我开上法拉利吗？ synchronized做了那些优化 这个问题以后碰到了再来看。 volatile是怎么实现可见性的 答： 当某个线程需要修改一个数据时，事实上步骤是如下的： 1、将主存中的数据加载到缓存中 2、CPU对缓存中的数据进行修改 3、将修改后的值刷新到内存中 但是不同的CPU之间是无法感知其他CPU对这个变量的修改的，最终就可能导致结果与我们的预期不符。 而使用了volatile关键字之后，情况就有所不同，volatile关键字有两层语义： 1、立即将缓存中数据写会到内存中 2、其他处理器通过嗅探总线上传播过来了数据监测自己缓存的值是不是过期了，如果过期了，就会对应的缓存中的数据置为无效。而当处理器对这个数据进行修改时，会重新从内存中把数据读取到缓存中进行处理。 在这种情况下，不同的CPU之间就可以感知其他CPU对变量的修改，并重新从内存中加载更新后的值，因此可以解决可见性问题。 ArrayList怎么扩容的 答: 添加一个元素，首先计算当前的array所需的最小容量的大小，判断是否需要扩容。 当需要扩容时： 得到当前的ArrayList的容量(oldCapacity)。 计算出扩容后的新容量(newCapacity)，其值(oldCapacity + (oldCapacity &gt;&gt;1))约是 oldCapacity 的1.5倍。 这里采用的是移位运算。为什么采用这种方法呢？应该是出于效率的考虑。 当newCapacity小于所需最小容量，那么将所需最小容量赋值给newCapacity。 newCapacity大于ArrayList的所允许的最大容量,处理。进行数据的复制，完成向ArrayList实例添加元素操作。 每次array的size到达当前的容量最大值后，再插入数据就会造成扩容。 映射器处理器是怎么通过URL找到对应的处理器的 以后碰到了在来看。 当你在浏览器地址栏输入一个URL后回车，浏览器做了什么？ 答： URL输入 DNS解析，将输入的网址解析成IP地址 TCP连接，经过三次握手建立TCP连接 1、第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 2、第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 3、第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 发送HTTP请求 客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分： 1、请求方法URI协议/版本。比如： GET/sample.jsp HTTP/1.1 2、请求头(Request Header)请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。比如： 123456Accept:image/gif.image/jpeg.*/*Accept-Language:zh-cnConnection:Keep-AliveHost:localhostUser-Agent:Mozila/4.0(compatible:MSIE5.01:Windows NT5.0)Accept-Encoding:gzip,deflate. 注意：请求头和请求正文之间有一个空行，这个空行非常重要，它表示请求头已经结束，接下来的是请求正文。 3、请求正文：请求正文中可以包含客户提交的查询字符串信息。比如： `username=jinqiao&amp;password=1234` 123合起来就是一个完整的HTTP请求例子 服务器处理请求 服务器响应请求 浏览器解析渲染页面 连接结束 还有map上的链表什么时候变成红黑树 答：链表长度为8的时候，初始化是链表保存的，其查找性能是O(n)，而树结构能将查找性能提升到O(log(n))。当链表长度很小的时候，即使遍历，速度也非常快，但是当链表长度不断变长，肯定会对查询性能有一定的影响，所以才需要转成树 这个时候就有一些面试管问：可是为什么是8呢？ 选择8是空间和时间的权衡，不是拍拍屁股决定的，是做java的那些人是根据概率统计决定的 什么是自旋锁 答：首先是一种锁，与互斥锁相似，基本作用是用于线程（进程）之间的同步。与普通锁不同的是，一个线程A在获得普通锁后，如果再有线程B试图获取锁，那么这个线程B将会挂起（阻塞）；试想下，如果两个线程资源竞争不是特别激烈，而处理器阻塞一个线程引起的线程上下文的切换的代价高于等待资源的代价的时候（锁的已保持者保持锁时间比较短），那么线程B可以不放弃CPU时间片，而是在“原地”忙等，直到锁的持有者释放了该锁，这就是自旋锁的原理，可见自旋锁是一种非阻塞锁。 对Lock相关锁的理解 什么是hash算法 答：百科是这样定义哈希算法的：哈希算法可以将任意长度的二进制值映射为较短的，固定长度的二进制值。我们把这个二进制值成为哈希值。 hash冲突怎么回事 答：由于哈希算法被计算的数据是无限的，而计算后的结果范围有限，因此总会存在不同的数据经过计算后得到的值相同，这就是哈希冲突 怎么解决hash冲突 答：解决哈希冲突的方法一般有：开放定址法、链地址法（拉链法）、再哈希法、建立公共溢出区等方法。具体解释Google或百度。 为什么循环删除ArrayList会出错 答： for循环删除数组里面的元素会向左移，list的长度也会发生变化，但是for循环中的i的数值是自增的，比如说上一次遍历到了第2个元素，下标为1，然后删除，下一次遍历i变成了3，但是第三个元素的下标还是1，这个时候第三个元素就会遍历不到，所以可能会导致少遍历了某个或几个元素。可以用list的长度自减的方式进行删除。 foreach循环删除元素的时候，foreach写法是对实际的Iterable、hasNext、next方法的简写，迭代器内部会做修改次数检查，所以会并发异常。要避免这种情况的出现则在使用迭代器迭代时（显示或for-each的隐式）不要使用ArrayList的remove，改为用Iterator的remove即可。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring的核心机制]]></title>
    <url>%2F2019%2F06%2F04%2FSpring%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[首先，Spring是一个轻量级的（面向切面AOP、IOC控制反转）容器框架。 Spring的优点： 降低组件之间的耦合性 使程序员更加专注于自己的核心业务，像日志、安全等抽出来统一处理 方便单元测试 方便事务处理 不强制应用完全依赖Spring，开发者可以自由选用Sprig的部分或全部功能 对主流框架提供了集成支持，如Hibernate，JPA，Struts等 属于低侵入式设计，代码污染度极低 提供了单例模式的支持 AOP和IOCAOP把业务逻辑和系统级别的服务分离开来，使程序员更加专注于自己的业务逻辑，而不需要管系统级别的服务。容器中的对象能享有容器中的公共服务（事务、安全等）。 原理AOP是基于动态代理的。用到了代理模式，代理模式是一种静态代理，而动态代理就是利用反射和动态编译将代理模式变成动态的。得知被代理类后通过反射得知他的一切信息，然后动态编译成代理类的class文件（动态组装成代理类，生成java文件，再编译成class文件）。 优点提供另外一种变成思路，可以把类似的行为抽出来统一处理。 IOC]]></content>
  </entry>
</search>
